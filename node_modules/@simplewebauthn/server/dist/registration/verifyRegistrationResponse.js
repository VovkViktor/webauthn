"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base64url_1 = __importDefault(require("base64url"));
const decodeAttestationObject_1 = __importDefault(require("../helpers/decodeAttestationObject"));
const decodeClientDataJSON_1 = __importDefault(require("../helpers/decodeClientDataJSON"));
const parseAuthenticatorData_1 = __importDefault(require("../helpers/parseAuthenticatorData"));
const toHash_1 = __importDefault(require("../helpers/toHash"));
const decodeCredentialPublicKey_1 = __importDefault(require("../helpers/decodeCredentialPublicKey"));
const convertCOSEtoPKCS_1 = require("../helpers/convertCOSEtoPKCS");
const convertAAGUIDToString_1 = __importDefault(require("../helpers/convertAAGUIDToString"));
const settingsService_1 = __importDefault(require("../services/settingsService"));
const generateRegistrationOptions_1 = require("./generateRegistrationOptions");
const verifyFIDOU2F_1 = __importDefault(require("./verifications/verifyFIDOU2F"));
const verifyPacked_1 = __importDefault(require("./verifications/verifyPacked"));
const verifyAndroidSafetyNet_1 = __importDefault(require("./verifications/verifyAndroidSafetyNet"));
const verifyTPM_1 = __importDefault(require("./verifications/tpm/verifyTPM"));
const verifyAndroidKey_1 = __importDefault(require("./verifications/verifyAndroidKey"));
const verifyApple_1 = __importDefault(require("./verifications/verifyApple"));
/**
 * Verify that the user has legitimately completed the registration process
 *
 * **Options:**
 *
 * @param credential Authenticator credential returned by browser's `startAuthentication()`
 * @param expectedChallenge The base64url-encoded `options.challenge` returned by
 * `generateRegistrationOptions()`
 * @param expectedOrigin Website URL (or array of URLs) that the registration should have occurred on
 * @param expectedRPID RP ID (or array of IDs) that was specified in the registration options
 * @param requireUserVerification (Optional) Enforce user verification by the authenticator
 * (via PIN, fingerprint, etc...)
 * @param supportedAlgorithmIDs Array of numeric COSE algorithm identifiers supported for
 * attestation by this RP. See https://www.iana.org/assignments/cose/cose.xhtml#algorithms
 */
async function verifyRegistrationResponse(options) {
    const { credential, expectedChallenge, expectedOrigin, expectedRPID, requireUserVerification = false, supportedAlgorithmIDs = generateRegistrationOptions_1.supportedCOSEAlgorithmIdentifiers, } = options;
    const { id, rawId, type: credentialType, response } = credential;
    // Ensure credential specified an ID
    if (!id) {
        throw new Error('Missing credential ID');
    }
    // Ensure ID is base64url-encoded
    if (id !== rawId) {
        throw new Error('Credential ID was not base64url-encoded');
    }
    // Make sure credential type is public-key
    if (credentialType !== 'public-key') {
        throw new Error(`Unexpected credential type ${credentialType}, expected "public-key"`);
    }
    const clientDataJSON = decodeClientDataJSON_1.default(response.clientDataJSON);
    const { type, origin, challenge, tokenBinding } = clientDataJSON;
    // Make sure we're handling an registration
    if (type !== 'webauthn.create') {
        throw new Error(`Unexpected registration response type: ${type}`);
    }
    // Ensure the device provided the challenge we gave it
    if (challenge !== expectedChallenge) {
        throw new Error(`Unexpected registration response challenge "${challenge}", expected "${expectedChallenge}"`);
    }
    // Check that the origin is our site
    if (Array.isArray(expectedOrigin)) {
        if (!expectedOrigin.includes(origin)) {
            throw new Error(`Unexpected registration response origin "${origin}", expected one of: ${expectedOrigin.join(', ')}`);
        }
    }
    else {
        if (origin !== expectedOrigin) {
            throw new Error(`Unexpected registration response origin "${origin}", expected "${expectedOrigin}"`);
        }
    }
    if (tokenBinding) {
        if (typeof tokenBinding !== 'object') {
            throw new Error(`Unexpected value for TokenBinding "${tokenBinding}"`);
        }
        if (['present', 'supported', 'not-supported'].indexOf(tokenBinding.status) < 0) {
            throw new Error(`Unexpected tokenBinding.status value of "${tokenBinding.status}"`);
        }
    }
    const attestationObject = base64url_1.default.toBuffer(response.attestationObject);
    const decodedAttestationObject = decodeAttestationObject_1.default(attestationObject);
    const { fmt, authData, attStmt } = decodedAttestationObject;
    const parsedAuthData = parseAuthenticatorData_1.default(authData);
    const { aaguid, rpIdHash, flags, credentialID, counter, credentialPublicKey } = parsedAuthData;
    // Make sure the response's RP ID is ours
    if (expectedRPID) {
        if (typeof expectedRPID === 'string') {
            const expectedRPIDHash = toHash_1.default(Buffer.from(expectedRPID, 'ascii'));
            if (!rpIdHash.equals(expectedRPIDHash)) {
                throw new Error(`Unexpected RP ID hash`);
            }
        }
        else {
            // Go through each expected RP ID and try to find one that matches
            const foundMatch = expectedRPID.some(expected => {
                const expectedRPIDHash = toHash_1.default(Buffer.from(expected, 'ascii'));
                return rpIdHash.equals(expectedRPIDHash);
            });
            if (!foundMatch) {
                throw new Error(`Unexpected RP ID hash`);
            }
        }
    }
    // Make sure someone was physically present
    if (!flags.up) {
        throw new Error('User not present during registration');
    }
    // Enforce user verification if specified
    if (requireUserVerification && !flags.uv) {
        throw new Error('User verification required, but user could not be verified');
    }
    if (!credentialID) {
        throw new Error('No credential ID was provided by authenticator');
    }
    if (!credentialPublicKey) {
        throw new Error('No public key was provided by authenticator');
    }
    if (!aaguid) {
        throw new Error('No AAGUID was present during registration');
    }
    const decodedPublicKey = decodeCredentialPublicKey_1.default(credentialPublicKey);
    const alg = decodedPublicKey.get(convertCOSEtoPKCS_1.COSEKEYS.alg);
    if (typeof alg !== 'number') {
        throw new Error('Credential public key was missing numeric alg');
    }
    // Make sure the key algorithm is one we specified within the registration options
    if (!supportedAlgorithmIDs.includes(alg)) {
        const supported = supportedAlgorithmIDs.join(', ');
        throw new Error(`Unexpected public key alg "${alg}", expected one of "${supported}"`);
    }
    const clientDataHash = toHash_1.default(base64url_1.default.toBuffer(response.clientDataJSON));
    const rootCertificates = settingsService_1.default.getRootCertificates({ identifier: fmt });
    // Prepare arguments to pass to the relevant verification method
    const verifierOpts = {
        aaguid,
        attStmt,
        authData,
        clientDataHash,
        credentialID,
        credentialPublicKey,
        rootCertificates,
        rpIdHash,
    };
    /**
     * Verification can only be performed when attestation = 'direct'
     */
    let verified = false;
    if (fmt === 'fido-u2f') {
        verified = await verifyFIDOU2F_1.default(verifierOpts);
    }
    else if (fmt === 'packed') {
        verified = await verifyPacked_1.default(verifierOpts);
    }
    else if (fmt === 'android-safetynet') {
        verified = await verifyAndroidSafetyNet_1.default(verifierOpts);
    }
    else if (fmt === 'android-key') {
        verified = await verifyAndroidKey_1.default(verifierOpts);
    }
    else if (fmt === 'tpm') {
        verified = await verifyTPM_1.default(verifierOpts);
    }
    else if (fmt === 'apple') {
        verified = await verifyApple_1.default(verifierOpts);
    }
    else if (fmt === 'none') {
        if (Object.keys(attStmt).length > 0) {
            throw new Error('None attestation had unexpected attestation statement');
        }
        // This is the weaker of the attestations, so there's nothing else to really check
        verified = true;
    }
    else {
        throw new Error(`Unsupported Attestation Format: ${fmt}`);
    }
    const toReturn = {
        verified,
    };
    if (toReturn.verified) {
        toReturn.registrationInfo = {
            fmt,
            counter,
            aaguid: convertAAGUIDToString_1.default(aaguid),
            credentialPublicKey,
            credentialID,
            credentialType,
            userVerified: flags.uv,
            attestationObject,
        };
    }
    return toReturn;
}
exports.default = verifyRegistrationResponse;
//# sourceMappingURL=verifyRegistrationResponse.js.map