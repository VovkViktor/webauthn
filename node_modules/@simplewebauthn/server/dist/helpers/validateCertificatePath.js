"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/ban-ts-comment */
// `ASN1HEX` exists in the lib but not in its typings
// @ts-ignore 2305
const jsrsasign_1 = require("jsrsasign");
const isCertRevoked_1 = __importDefault(require("./isCertRevoked"));
const { crypto } = jsrsasign_1.KJUR;
/**
 * Traverse an array of PEM certificates and ensure they form a proper chain
 * @param certificates Typically the result of `x5c.map(convertASN1toPEM)`
 * @param rootCertificates Possible root certificates to complete the path
 */
async function validateCertificatePath(certificates, rootCertificates = []) {
    if (rootCertificates.length === 0) {
        // We have no root certs with which to create a full path, so skip path validation
        // TODO: Is this going to be acceptable default behavior??
        return true;
    }
    let invalidSubjectAndIssuerError = false;
    for (const rootCert of rootCertificates) {
        try {
            const certsWithRoot = certificates.concat([rootCert]);
            await _validatePath(certsWithRoot);
            // If we successfully validated a path then there's no need to continue
            invalidSubjectAndIssuerError = false;
            break;
        }
        catch (err) {
            if (err instanceof InvalidSubjectAndIssuer) {
                invalidSubjectAndIssuerError = true;
            }
            else {
                throw err;
            }
        }
    }
    // We tried multiple root certs and none of them worked
    if (invalidSubjectAndIssuerError) {
        throw new InvalidSubjectAndIssuer();
    }
    return true;
}
exports.default = validateCertificatePath;
async function _validatePath(certificates) {
    if (new Set(certificates).size !== certificates.length) {
        throw new Error('Invalid certificate path: found duplicate certificates');
    }
    // From leaf to root, make sure each cert is issued by the next certificate in the chain
    for (let i = 0; i < certificates.length; i += 1) {
        const subjectPem = certificates[i];
        const subjectCert = new jsrsasign_1.X509();
        subjectCert.readCertPEM(subjectPem);
        let issuerPem = '';
        if (i + 1 >= certificates.length) {
            issuerPem = subjectPem;
        }
        else {
            issuerPem = certificates[i + 1];
        }
        const issuerCert = new jsrsasign_1.X509();
        issuerCert.readCertPEM(issuerPem);
        // Check for certificate revocation
        const subjectCertRevoked = await isCertRevoked_1.default(subjectCert);
        if (subjectCertRevoked) {
            throw new Error(`Found revoked certificate in certificate path`);
        }
        // Check that intermediate certificate is within its valid time window
        const notBefore = jsrsasign_1.zulutodate(issuerCert.getNotBefore());
        const notAfter = jsrsasign_1.zulutodate(issuerCert.getNotAfter());
        const now = new Date();
        if (notBefore > now || notAfter < now) {
            throw new Error('Intermediate certificate is not yet valid or expired');
        }
        if (subjectCert.getIssuerString() !== issuerCert.getSubjectString()) {
            throw new InvalidSubjectAndIssuer();
        }
        const subjectCertStruct = jsrsasign_1.ASN1HEX.getTLVbyList(subjectCert.hex, 0, [0]);
        const alg = subjectCert.getSignatureAlgorithmField();
        const signatureHex = subjectCert.getSignatureValueHex();
        const Signature = new crypto.Signature({ alg });
        Signature.init(issuerPem);
        Signature.updateHex(subjectCertStruct);
        if (!Signature.verify(signatureHex)) {
            throw new Error('Invalid certificate path: invalid signature');
        }
    }
    return true;
}
// Custom errors to help pass on certain errors
class InvalidSubjectAndIssuer extends Error {
    constructor() {
        const message = 'Subject issuer did not match issuer subject';
        super(message);
        this.name = 'InvalidSubjectAndIssuer';
    }
}
//# sourceMappingURL=validateCertificatePath.js.map